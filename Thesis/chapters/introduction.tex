\section{Current Situation}

JavaScript has become an essential part of modern software development, extending far beyond its original purpose of enhancing website interactivity. Today, it powers web applications, server-side platforms, and even mobile and desktop software. However, its widespread adoption has also revealed significant challenges related to maintainability, scalability and reliability. 

JavaScript’s core design prioritizes flexibility and dynamic typing, allowing developers to write expressive code with minimal constraints. While this adaptability has fuelled its success, it has also led to issues such as type ambiguity, runtime-bound error handling, and difficulties in managing large-scale applications. Implicit type coercion and dynamic typing often result in unexpected behaviour and runtime failures that can be hard to trace. 

To address these challenges, various tools and languages have been developed, with TypeScript being the most widely adopted. By introducing static type checking and enhanced development features while maintaining JavaScript compatibility, TypeScript helps mitigate some of JavaScript’s weaknesses. However, its compile-time-only type safety still leaves room for runtime inconsistencies in dynamic environments. This especially becomes hazardous due to the inconsistent error reporting present in JavaScript. Many operations fail silently and simply return an undefined value, which isn't clearly identifiable without foresight and proper precautions. As a result, errors may manifest several lines after the initial fault or even minutes or hours later, depending on when the affected data is accessed or validated.

While some of these issues can be mitigated through the use of linters and safe coding practises, they typically rely on the user to correctly identify issues and account for all potential edge cases of an operation. This, however, proves dangerous, as allowing users to manage security within an environment creates a hazard for potential edge cases and complex issues that may not be easily resolved through debugging or detailed program analysis.

\section{Goal of the Thesis}

Kipper seeks to enhance these existing web languages, such as JavaScript and TypeScript, by offering a runtime environment that includes runtime type checks, type determination, and pattern matching—features previously absent in these ecosystems. This approach allows developers to properly identify types and compare them with defined structures during compile- and runtime, ensuring all aspects of an application are correctly validated. However, Kipper would not aim to replace these languages; rather, it should extend them by providing a comprehensive type system and language that accounts for all edge cases and eliminates untyped or potentially unsafe operations.

To achieve this goal, a compiler should be developed as part of this thesis to provide these type safety features while generating output code compatible with both JavaScript and TypeScript environments. It would function similarly to other well-known \gls{transpiler}s, such as the TypeScript transpiler, and operate based on the Kipper programming language. This language would share similarities with TypeScript but incorporate syntax elements from other languages, such as Python, to simplify various development processes. Its most important element would be the Kipper type system, which would be inherently strict and definitive, preventing the assignment of incorrect or malformed data. This type system should incorporate interface-based duck typing and \gls{object-oriented-programming} (OOP) paradigms to enable flexible yet safe development.

\section{Related Work}

While the Kipper language is generally not unique in its methods nor its capabilities, its most important features are achieved through the strict reliance on a closed type system. This generally differentiates it from other projects aiming to solve similar problems as previously outlined.

A language is generally considered a fairly large undertaking, which requires a lot of justification for why it provides a benefit over existing solutions. In the case of Kipper, it can be argued that one of the many runtime libraries could achieve a similar result with less overhead, but in general this can be refuted with the issue of continued reliance on the developer and their safety precautions. As a library generally adds another layer of complexity, there is yet another responsibility for the developer to properly maintain and safely utilize the provided functionality. In this case, this would mean maintaining another set of runtime types that can be then used for type comparisons and checks. 

Besides relying on a library to manage types, a statically compile-time-typed language such as TypeScript could be used. As previously mentioned, TypeScript provides a type system that allows types to be assigned to various data structures, offering a largely comprehensive type framework. However, it only accounts for the information explicitly provided by the user and cannot make reliable assertions about the actual runtime states of variables or incoming data. An alternative approach would be to implement the necessary type checks manually wherever ambiguity arises. However, this becomes challenging for large objects, as every nested structure would need to be recursively verified, adding significant complexity to the design of a safe system.

Furthermore, there is no guarantee that the chosen system will work as intended, as it is left up to the developer to decide when and how to use it, which only worsens the problem of inconsistent and incoherent type safety.

\section{Preexisting elements}

It is important to note that Kipper was not originally conceived as a thesis project or a high-level language in its current form but began as a minor personal project around September 2021. The language evolved over time due to an interest in building upon the JavaScript ecosystem while addressing its commonly perceived limitations.

Initially, Kipper incorporated fundamental features such as arithmetic operations, low-level data types as well as user-defined and built-in functions. With the introduction of major features—including error recovery, complex object types, runtime types, and classes—the language has significantly increased in complexity. In its core functionality, Kipper can now be compared to early versions of languages such as JavaScript or Python. This thesis represents a substantial advancement for what was originally a small-scale project. With continued development, Kipper is expected to achieve a full core feature set and direct integration with existing environments in the coming years.

However, as of the time of writing, while Kipper is feature-complete within its planned scope, it does not yet include all features commonly found or required in modern programming languages. Essential functionalities such as imports, modules, and asynchronous operations are currently absent from the language.

Furthermore, this thesis should be regarded as a snapshot of the project's development rather than a comprehensive account of its entire history. It primarily focuses on the key features implemented during the 2024/25 period, when Kipper took its current form. Additionally, this thesis does not assert that the language will strictly adhere to all specifications outlined in this paper, nor does it guarantee backward compatibility with the described features. As Kipper remains in active development, it will continue evolving to achieve a standard feature set suitable for a major v1.0 release.

\section{Structure of the Thesis}

With this in mind, this paper will discuss the background and challenges present in the web environment, examine various aspects of the Kipper compiler—including its design and the decisions made during its development—and inspect the role of Kipper and how it can help achieve a safer development process.

In Chapter \nameref{chapter:background}, we will discuss the issues present in modern web environments and the underlying motivation for Kipper and its design. Following that, Chapter \nameref{chapter:tech} will talk about the concrete implementation and the technologies used throughout the project. Furthermore, Chapter \nameref{chapter:type-system} presents the chosen design for the type system and its extent within Kipper. This is followed by Chapter \nameref{chapter:implementation}, where the design choices, implementation details and the scope of the Kipper Compiler are thoroughly discussed. To showcase the various methods available to use Kipper, Chapter \nameref{chapter:compiler-ref} presents the Compiler API and CLI. This is then followed up by Chapter \nameref{chapter:demo}, which presents various Kipper programs as examples for the capabilities of the language. The last Chapter \nameref{chapter:conclusion-future} outlines the projected future for the project and its potential direction following the completion of this thesis.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../thesis"
%%% End: