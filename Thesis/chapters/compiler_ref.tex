\setauthor{Lorenz Holzbauer}

This chapter explores the various ways to interact with the Kipper compiler and its systems through the exposed Kipper API. Since the compiler serves as the core of the project, utilizing the language effectively requires setting up the compiler and integrating it properly for specific use cases.

The API provides all the essential functionality needed to compile and \gls{transpile} Kipper code, enabling developers to integrate it into their workflows. Additionally, the API exposes core interfaces, classes, and types that allow users to extend and modify the compilerâ€™s behaviour. This means developers can inherit from existing components or introduce custom modifications to tailor the compilation process to their needs.

\section{Compiler API}
\label{sec:compiler_api}

The Kipper Compiler API provides the functionality required to compile Kipper source code into JavaScript or TypeScript. The primary entry points into the API are the \lstinline|KipperCompiler| class, which offers core compilation functionality and facilitates file processing, and the \lstinline|KipperProgramContext| class, which stores contextual information about a performed compilation and can be referenced for additional program metadata.

\subsection{Initializing the Compiler}
\label{subsec:compiler_init}

To compile Kipper code, an instance of \lstinline|KipperCompiler| must be created. The compiler requires a logger instance and an optional configuration object.

\begin{lstlisting}[language=Typescript, caption=Initializing the Kipper Compiler, label=lst:compiler_initialization]
import * as kipper from "@kipper/core";
	
const logger = new kipper.KipperLogger((level, msg) => {
	console.log(`[${Kipper.getLogLevelString(level)}] ${msg}`);
});

const compiler = new kipper.KipperCompiler(logger, {});
\end{lstlisting}

The logger instance provides error reporting functionality, making it an essential part of the compilation process.

\subsection{Compiling Kipper Code}
\label{subsec:compiling}

Once the compiler is initialized, it can be used to \gls{transpile} Kipper code into JavaScript or TypeScript. The \lstinline|compile| method takes the source code as a string and a configuration object specifying the compilation target.

\begin{lstlisting}[language=Typescript, caption=Compiling Kipper Code to JavaScript, label=lst:compile_example]
import * as kipperJS from "@kipper/target-js";
	
const result = await compiler.compile(
	`print("Hello world!");`,
	{ target: new kipperJS.TargetJS() }
);
const jsCode = result.write();

// Execute the compiled JavaScript
eval(jsCode);
\end{lstlisting}

The compilation result is an object containing the generated JavaScript or TypeScript code, which can be executed or written to a file.

\subsection{Compilation Options}
\label{subsec:compilation_options}

The \lstinline|compile| method accepts a configuration object that allows customization of the compilation process. The most important options are:

\begin{itemize}
	\item \lstinline|target|: Specifies the output language. Available targets are \lstinline|TargetJS| for JavaScript and \lstinline|TargetTS| for TypeScript.
	\item \lstinline|filename|: Specifies the filename of the generated code.
	\item \lstinline|optimisationOptions|: Currently
	\lstinline|optimiseInternals| and \lstinline|optimiseBuiltIns| are available. They can be enabled by setting them to \lstinline|true|.
\end{itemize}

\subsection{Accessing compilation metadata and potential errors}

The Kipper compiler returns upon the execution of \lstinline|compile| a result object storing all compilation-related information. This instance of the class \lstinline|KipperCompileResult| represents the result of the compilation and depending on the success of the compilation will contain various program metadata. 

The following properties and methods are exposed by \lstinline|KipperCompileResult|:

\begin{itemize}
	\item \lstinline|programCtx|: An instance of \lstinline|KipperProgramContext| stores all essential metadata of the program, including the parse tree, \acrshort{ast}, global symbol table, internal references, compiler arguments, and other relevant information. It contains everything generated by the compiler. However, it may be \lstinline|undefined| if syntax errors occur during compilation, preventing the construction of an AST and any subsequent analysis.
	\item \lstinline|result|: The result of the compilation represented as an array containing string arrays, where each string array represents the individual lines and their corresponding tokens.
	\item \lstinline|success|: A boolean field indicating the success of the compilation.
	\item \lstinline|warnings|: The list of warnings reported by the compiler.
	\item \lstinline|errors|: The list of encountered syntax errors or semantic errors.
	\item \lstinline|write(lineEnding: string = "\n")|: Writes the whole translated program to a string.
\end{itemize}

\section{Target API}
\label{sec:target_api}

The Kipper compiler supports multiple compilation targets, allowing the \gls{transpilation} of Kipper code into different languages. Developers can extend Kipper by implementing custom targets.

\subsection{Using Predefined Targets}
\label{subsec:using_targets}

Kipper provides predefined targets for JavaScript and TypeScript. These can be used as follows:

\begin{lstlisting}[language=Typescript, caption=Using Compilation Targets, label=lst:using_targets]
import * as kipperJS from "@kipper/target-js";
import * as kipperTS from "@kipper/target-js";

const jsTarget = new kipperJS.TargetJS();
const tsTarget = new kipperTS.TargetTS();
\end{lstlisting}

\subsection{Creating Custom Targets}
\label{subsec:custom_targets}

To create a custom target, a new class must extend \lstinline|KipperCompileTarget| and implement the three required classes for translation. As demonstrated in listing~\ref{lst:custom_target}, the three classes \lstinline|CustomTargetSemanticAnalyser|, \lstinline|CustomTargetCodeGenerator|, and \lstinline|CustomTargetBuiltInGenerator| each define the various functionality required for translating a program. These classes are grouped within the target class \lstinline|CustomTarget|, which can then be passed to a compilation.

\begin{lstlisting}[language=Typescript, caption=Creating a Custom Compilation Target, label=lst:custom_target]
import { KipperCompileTarget, KipperTargetBuiltInGenerator, TranslatedExpression } from "@kipper/core";
	
export class CustomTargetSemanticAnalyser extends KipperTargetSemanticAnalyser {
	...
}

export class CustomTargetCodeGenerator extends KipperTargetCodeGenerator {
	...
}

export class CustomTargetBuiltInGenerator extends KipperTargetBuiltInGenerator {
	...
}

class CustomTarget extends KipperCompileTarget {
	constructor() {
		super(
			"MyLanguage",  // name
			new CustomTargetSemanticAnalyser(), 
			new CustomTargetCodeGenerator(), 
			new CustomTargetBuiltInGenerator(), 
			"ext" // file extension
		);
	}
}
\end{lstlisting}

Creating a custom target requires the implementation of the translation for all Kipper \acrshort{ast} nodes and the definition of the required built-in functions. Additionally, custom semantic checks can be implemented if specific requirements apply to a given target.

\section{Command Line Interface (CLI)}
\label{sec:cli}

The Kipper CLI provides a command-line interface for compiling Kipper code and managing a project within a local system directory. The CLI is available via the \lstinline|@kipper/cli| package.

\subsection{Installing the CLI}
\label{subsec:cli-installation}

To install the Kipper CLI using the JavaScript package manager npm, use the following command:

\begin{lstlisting}[language=Shell,caption=Installing Kipper CLI, label=lst:cli_install]
npm install @kipper/cli
\end{lstlisting}

This installs Kipper in the current npm project environment. 

To install Kipper globally, use the \lstinline|-g| flag. This may require superuser privileges, depending on the installation location.

\subsection{Compiling a File}
\label{subsec:cli-compile}

To compile a Kipper source file, use the \lstinline|kipper compile| command:

\begin{lstlisting}[language=Shell,caption=Compiling a Kipper file, label=lst:cli_compile]
kipper compile source.kip --target js
\end{lstlisting}

This command \gls{transpile}s \lstinline|source.kip| to JavaScript. It is possible to specify the option \lstinline|--target=ts| to switch to the TypeScript target. When no target option is specified, the default target is JavaScript.

\subsection{Running a Kipper Program}

To run a Kipper source file, use the \lstinline|kipper run| command:

\begin{lstlisting}[language=Shell,caption=Running a Kipper file, label=lst:cli_run]
kipper run source.kip
\end{lstlisting}

This command \gls{transpile}s to the specified target and then executes the code.

\subsection{Creating a New Project}
\label{subsec:cli-new_project}

To create a new Kipper project, use:

\begin{lstlisting}[language=Shell,caption=Creating a new Kipper project with a default file setup and config file, label=lst:cli_new_project]
kipper new my_project
\end{lstlisting}

This generates a new project with a configuration file that specifies the compiler arguments, which are automatically passed to the compiler upon invocation.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../thesis"
%%% End: