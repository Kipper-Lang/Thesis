\section{Potential Features}
\label{sec:future}
\setauthor{Lorenz Holzbauer}

Currently, Kipper primarily serves web developers by offering integration with the TypeScript (TS) and JavaScript (JS) ecosystems. However, Kipper remains in the early stages of development as a modern programming language, and several features common in other languages have yet to be implemented. The following sections will discuss these features and explore potential experimental functionality.

\subsection{WebAssembly Support}
WebAssembly (Wasm) is a low-level, binary instruction format designed as a portable compilation target for high-performance applications. It allows code to run efficiently across diverse execution environments, including web browsers, cloud services, and embedded systems. By enabling near-native performance, WebAssembly facilitates applications that require intensive computation or low-latency execution. Given the increasing adoption of WebAssembly in cloud and server-side applications, extending Kipper to support Wasm as a compilation target presents an opportunity to enhance performance, portability, and deployment flexibility.

Incorporating WebAssembly as a target for Kipper introduces multiple advantages. The potential for improved execution speed is one of the most significant benefits, as WebAssembly executes more efficiently than JavaScript due to its statically typed nature and optimized memory handling. Unlike JavaScript and TypeScript, which depend on runtime interpretation, WebAssembly enables Kipper programs to be compiled ahead of time, resulting in lower runtime overhead and faster execution.

Additionally, WebAssembly facilitates the development of standalone applications, making it possible for Kipper programs to run independently of JavaScript runtime environments such as NodeJS. This characteristic is particularly beneficial for server-side applications and microservices. Furthermore, due to its compact binary format, WebAssembly modules require less memory compared to traditional virtualized environments, thereby reducing startup time and improving efficiency. Technologies like Wasmer demonstrate that WebAssembly can function as a lightweight alternative to traditional containerized environments while maintaining strong isolation and security properties.

Despite these advantages, integrating WebAssembly into Kipper presents several technical challenges. A major hurdle is memory management, as WebAssembly does not include built-in garbage collection. While experimental support for garbage collection in WebAssembly is under development, Kipper’s runtime model would require significant adjustments to manage memory allocation and deallocation efficiently. Furthermore, integrating WebAssembly as a compilation target requires a well-defined mechanism for interoperability with JavaScript, ensuring that Kipper-generated Wasm modules can interface seamlessly with JavaScript-based systems. The Kipper standard library, which currently relies on JavaScript APIs, would also need extensive modifications to accommodate WebAssembly’s execution model.

Given the complexity of these challenges, full WebAssembly support for Kipper is not planned for the foreseeable future. The significant technical hurdles associated with type system modifications, memory management, and standard library adaptation make WebAssembly integration infeasible at this stage of Kipper's development. While an initial proof of concept could theoretically evaluate the feasibility of compiling simple Kipper functions to WebAssembly, the extensive modifications required for full compatibility outweigh the potential benefits at this time. As a result, Kipper will remain focused on its existing compilation targets, prioritizing improvements and optimizations within the JavaScript and TypeScript ecosystems.

\subsection{IDE Support}

The integration of a programming language into an integrated development environment (IDE) plays a fundamental role in its adoption and usability. Effective IDE support facilitates code writing, debugging, and maintenance by providing features such as syntax highlighting, code completion, error detection, and debugging tools. Given that Kipper transpiles to TypeScript (TS) and JavaScript (JS), ensuring comprehensive IDE support is essential for practical usability.

A primary component of IDE support is syntax highlighting. By distinguishing keywords, data types, function names, and operators through distinct visual cues, syntax highlighting improves code readability and reduces cognitive effort for developers. While Kipper currently provides syntax highlighting in its web-based editor, expanding this feature to widely used IDEs such as Visual Studio Code (VS Code) and IntelliJ IDEA would increase accessibility and efficiency.

Additionally, a standardized code formatter is required to ensure consistency across Kipper projects. Existing formatting tools such as Prettier and ESLint are widely adopted in TS and JS environments. A Kipper-specific formatter, following established formatting conventions, would improve code maintainability.

Modern IDEs incorporate intelligent code assistance features, commonly referred to as IntelliSense in VS Code. These features include code completion, which suggests function names, variables, and methods dynamically based on context. Parameter hints display expected function parameters to assist in correct API usage. Hover documentation provides inline explanations for functions, types, and keywords, enhancing code comprehension. Finally, symbol navigation enables quick access to function definitions, imports, and variable declarations. To enable these features, a Language Server Protocol (LSP) implementation specific to Kipper is necessary, allowing real-time context-aware suggestions and streamlining the development workflow.

Static analysis tools contribute to code quality by identifying potential issues and enforcing best practices. A dedicated Kipper linter could detect syntax errors prior to transpilation, warn about potential runtime issues, provide recommendations for writing idiomatic Kipper code, and enforce coding conventions such as indentation styles and variable naming patterns. A rule-based linter, similar to ESLint for JavaScript, would facilitate maintaining high-quality code and ensuring adherence to standardized practices.

\begin{figure}[h!]
	\centering
	\includegraphics[width=.8\linewidth]{./pics/developersurvey2024.png}
	\caption{The most popular integrated development environments (IDEs) among developers, according to the 2024 Stack Overflow Developer Survey. Visual Studio Code dominates the ranking with 73.6\% usage, followed by Visual Studio and IntelliJ IDEA.}
	\label{fig:future:developersurvey}
\end{figure}

A recent developer survey indicates that Visual Studio Code is the most widely used IDE, with approximately twice as many users as Visual Studio, which holds the second position ~\cite{stackoverflow2024}. IntelliJ IDEA ranks third in popularity. The preference for VS Code can be attributed to its lightweight nature, extensive extension marketplace, and strong integration with JavaScript and TypeScript ecosystems. This data supports the decision to prioritize VS Code support in the initial phases of Kipper’s IDE integration strategy.

\section{Integration with other languages}
\setauthor{Luna Klatzer}

\section{Project Result}
\setauthor{Luna Klatzer}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../thesis"
%%% End:
