\section{Internal Compiler}
\setauthor{Luna Klatzer}

\section{Semantic Analysis}
\setauthor{Luna Klatzer}

\section{Type Analysis}
\setauthor{Luna Klatzer}

\section{Output Generation}
\setauthor{Lorenz Holzbauer}

\subsection{Introduction}

\subsection{Algorithms used for Output Generation}

\subsection{Types of Generated Statements}

\subsection{Differences between the Target Languages}

\subsection{Stylistic Choices}

\section{Type System}
\setauthor{Fabian Baitura}

\section{Integrated Runtime}
\setauthor{Lorenz Holzbauer}

\subsection{Runtime Type Concept}
The primary goal of the Kipper runtime type system is to allow the comparison of untyped objects with clearly defined types, such as primitives, classes and interfaces which allows to remove any vagueness that could potentially lead to errors. At compile time, objects are given a type property, which allows the matching of types at runtime. This property always contains a name to identify the object. The implementation can be seen in ~\ref{lst:implementation:runtimetypestructure}. For primitive data types, this is the only instantiated field. Interfaces have a non-null fields value as this represents the properties of an interface. To allow comparing the functions of interfaces, the methods property stores type information about these types. To be future proof in regards to  inheritance, the "baseType" property is available, although it remains unused as of today.

\begin{lstlisting}[language=TypeScript,caption=The structure of a runtime type,label=lst:implementation:runtimetypestructure]
	class KipperType {  
		constructor(name, fields, methods, baseType = null) {  
			this.name = name;  
			this.fields = fields;  
			this.methods = methods;  
			this.baseType = baseType;  
		}
		
		isCompatibleWith(obj) {  
			return this.name === obj.name;  
		}
	}
\end{lstlisting}

 Kipper uses a nominal type system for primitives and classes. These compare types by type-name. Therefore two objects are equal, if their type name is equal. For Kipper, a nominal approach was not enough. To match interfaces and types against objects of an unknown type, it was necessary to implement duck typing. Duck typing compares the properties and methods of two objects for equality and ignores the type name. Both approaches and a third one will be further explained in chapter ~\ref{chap:runtime-other-languages}.
 
To check for type compatibility, every type brings its own comparer function. The default, as seen in snippet ~\ref{lst:implementation:runtimetypestructure}, is a nominal comparison, which can be overwritten for complex type assignments. This is especially important for casts, as types with additional properties can still be compatible to the base type.

\subsection{Runtime Type Implementations in other Languages}
\label{chap:runtime-other-languages}




\subsection{Runtime Generation for Builtin Types}

\subsection{Runtime Generation for Interfaces}

\subsection{Matches operator}

\subsection{Typeof operator}
