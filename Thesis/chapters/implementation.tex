\section{Internal Compiler}
\setauthor{Luna Klatzer}

\section{Semantic Analysis}
\setauthor{Luna Klatzer}

\section{Type Analysis}
\setauthor{Luna Klatzer}

\section{Output Generation}
\setauthor{Lorenz Holzbauer}

\subsection{Introduction}

\subsection{Algorithms used for Output Generation}

\subsection{Types of Generated Statements}

\subsection{Differences between the Target Languages}

\subsection{Stylistic Choices}

\section{Type System}
\setauthor{Fabian Baitura}

\section{Integrated Runtime}
\setauthor{Lorenz Holzbauer}

\subsection{Runtime Type Concept}

The primary goal of the Kipper runtime type system is to allow the comparison of untyped objects with clearly defined types, such as primitives, classes and interfaces which allows to remove any ambiguity that could potentially lead to errors. When the user code is generated, all user-defined interfaces are translated into runtime types, which store the information necessary to do a type check against a given object. This allows the compiler to generate required checks against these runtime types in places where the user is performing a cast or match operation using an interface. In the case of user-defined classes, the compiler has no need to translate any structural information, as classes rely on a prototype system which means they can use simple "instanceof" (prototype equality) checks. Alongside the code generation for user-defined structures, the compiler also inserts the built-in primitive structures and generics such as the "Array" and "Func" type into the output code. The implementation for a simple runtime type can be seen in 3. 

With the exception of interfaces and classes, types primarily differentiate themselves using their name, which means baseline checks are simply performed using equality checks. In more advanced use cases, such as interfaces, the required fields and methods are also taken into account; these represent the minimum blueprint an object must implement to match the given type. In this way, Kipper implements the same duck-typing system also present in TypeScript. To be future-proof in regards to inheritance, the "baseType" property is also available, although it remains unused as of today.

\begin{lstlisting}[language=TypeScript,caption=The structure of a runtime type,label=lst:implementation:runtimetypestructure]
class KipperType {
	constructor(name, fields, methods, baseType = null, customComparer = null) {
		this.name = name; 
		this.fields = fields;
		this.methods = methods;
		this.baseType = baseType;
		this.customComparer = customComparer;
	}

	accepts(obj) {
		if (this === obj) return true;
		return obj instanceof KipperType && this.customComparer ? this.customComparer(this, obj) : false;
	}
}
\end{lstlisting}

 Kipper uses a nominal type system for primitives. This means, that two types are compared by their name. Classes, on the other hand, are compared using JavaScripts prototype chain. Therefore they are equal, only if they are the same instance.   To match interfaces and types against objects of an unknown type, it was necessary to implement duck typing. Duck typing compares the properties and methods of two objects for equality and ignores the type name. Both approaches and a third one will be further explained in chapter ~\ref{chap:runtime-other-languages}. 

To check for type compatibility, every type brings its own comparer function. In case no comparer is supplied, it returns false.

 A snippet of the implementation of the builtin runtime types can be seen in \ref{lst:implementation:builtinruntimetypes}. Nominal comparison is implemented in the "\_\_type\_undefined" and the "\_\_type\_str" constants. "Any" is an exception, as it is necessary to cast it to a different type in order to return a useful value. By design "any" is as useless as possible, in order to force the developer into typechecking it.

\begin{lstlisting}[language=TypeScript,caption=The builtin runtime types,label=lst:implementation:builtinruntimetypes]
	const __type_any = 
		new KipperType('any', undefined, undefined);
		
	const __type_undefined = 
		new KipperType('undefined', undefined, undefined, undefined, (a, b) => a.name === b.name);
		
	const __type_str = 
		new KipperType('str', undefined, undefined, undefined, (a, b) => a.name === b.name);
\end{lstlisting}

\subsection{Runtime Type Implementations in other Languages}
\label{chap:runtime-other-languages}
Nominal type systems are used in most modern object-orientated programming languages like Java and C\#.  In these systems, types are compared by their name. Furthermore they are treated as equal, if one type is a subtype of the other one, as can bee seen in example \ref{lst:implementation:javanominaltyping}. Here a Programmer is an Employee, but not the other way around. This means, that Programmers have all the properties and methods an Employee has, but can additionally bring their own. The relationships are inherited, so a SeniorDeveloper is still an Employee, and a Programmer at the same time. Even though the Senior Developer adds no new functionality to the Programmer, it is not treated the same. Nominal typing improves code readability and maintainability, due to the explicit inheritance declaration. On the other hand, this increases code redundancy for similar, but not related structures.


\begin{lstlisting}[language=Java,caption=Example of nominal typing in java,label=lst:implementation:javanominaltyping]
class Employee {
	public float salary;
}

class Programmer extends Employee {
	public float bonus;
}

class SeniorDeveloper extends Programmer { }
\end{lstlisting}


Structural type systems compare types by their structure. This means, if two differently named types have the same properties and methods, then they are the same type. An example of this would be OCaml, with it's object subsystem being typed this way. Classes in OCaml only serve as functions for creating objects. In example \ref{lst:implementation:ocamlstructuraltyping} there is a function that required a function "speak" returning the type "string". Both the "dog" object as well as the "cat" object fulfill this condition, therefore both are treated equal. Most importantly, these compatibility checks happen at compile time, as OCaml is a static language. Structural typing allows for a lot of flexibility as it promotes code reuse. Furthermore it avoids explicit inheritance hierarchies.

\begin{lstlisting}[language=caml,caption=Example of structural typing in Ocaml,label=lst:implementation:ocamlstructuraltyping]
	let make_speak (obj : < speak : string >) =
	obj#speak
	
	let dog = object
	method speak = "Woof!"
	end
	
	let cat = object
	method speak = "Meow!"
	end
	
	let () =
	print_endline (make_speak dog);
	print_endline (make_speak cat);
\end{lstlisting}

Duck Typing is the usage of a structural type system in dynamic languages. It is the practical application of the Duck Test, therefore if it quacks like a duck, and walks like a duck, then it must be a duck. In programming languages this means that if an object has all methods and properties required by a type, then it is that type. The most prominent language utilizing Duck Typing is JavaScript. As can be seen in example \ref{lst:implementation:javascriptducktyping}, the duck and the person have the same methods and properties, henceforth they are of the same type. The dog object on the other hand does not implement the "quack" function, which equates to not  being a duck. Duck typing simplifies the code by removing type constraints, while still encouraging polymorphism without complex inheritance. Due to the type checking happening at runtime, errors only surface at this time, potentially causing failures. For developers, the lack of type information makes understanding the code harder and more tedious to maintain.

\begin{lstlisting}[language=Typescript,caption=Example of duck typing in JavaScript,label=lst:implementation:javascriptducktyping]
const duck = {
	quack: function () {
		console.log("Quack!");
	}
};

const person = {
	quack: function () {
		console.log("I'm a person but I can quack!");
	}
};

const dog = {
	bark: function () {
		console.log("Woof!");
	}
};
\end{lstlisting}

\subsection{Runtime Generation for Interfaces}
The generation of runtime interface types allows for dynamic type checking against interfaces in the target languages. This process is managed by the RuntimeTypesGenerator class, which is called by the code-generator and adds a JavaScript object to the compiled code that represents the structure of the interface. It therefore includes the interface's methods and properties with their respective types.

\begin{lstlisting}[language=Typescript,caption=Example interfaces in the Kipper language,label=lst:implementation:inputinterface]
interface Car {
	brand: str;
	honk(volume: num): void;
	year: num;
}

interface Person {
	name: str;
	age: num;
	car: Car;
}
\end{lstlisting}

 At compile time, the generator function iterates over the interface's members and differentiates between properties and methods. The function keeps separate lists of already generated runtime representations for properties and methods.
 
 If it detects a property, the type and semantic data of the given property is extracted. When the property's type is a built in type, the respective runtime type of the previous section is used. If not, we can assume the property's type is another interface, which has it's own runtime type already. This data is stored in "\_\_kipper.Property", which is finally added to the list of generated runtime type representation
 
 In case a method is detected, the generator function fetches the return type and the method's name. If the method has arguments, the name and type of each argument gets evaluated and stored in the same internal Kipper type as above, because the type representation of properties and arguments is equivalent. After that, it gets added to the list of type representations as well.

\begin{lstlisting}[language=Typescript,caption=The runtime representation of the previous interfaces,label=lst:implementation:runtimeinterface]
const __intf_Car = new __kipper.Type(
	"Car",
	[
		new __kipper.Property("brand", __kipper.builtIn.str),
		new __kipper.Property("year", __kipper.builtIn.num),
	],
	[
		new __kipper.Method("honk", __kipper.builtIn.void, 
			[
				new __kipper.Property("volume", __kipper.builtIn.num),
			]
		),
	]
);

const __intf_Person = new __kipper.Type(
	"Person",
	[
		new __kipper.Property("name", __kipper.builtIn.str),
		new __kipper.Property("age", __kipper.builtIn.num),
		new __kipper.Property("car", __intf_Car),
	],
	[]
);
\end{lstlisting}

The generated output code in the target language is a string array, which later gets concatenated into a single output string as can bee seen in \ref{lst:implementation:codegenerationstatement}. The properties and methods are wrapped into a Kipper type object that represents the final interface runtime type. It is saved into a constant with a \_\_intf\_ prefix. This runtime type-checking object code is then placed under the compiled interface's code. Notable usages for runtime typechecking include the "matches" operator \ref{subsec:matches} and the typeof operator \ref{subsec:typeof}.

\begin{lstlisting}[language=Typescript,caption=Code generation statement ,label=lst:implementation:codegenerationstatement]
return [
	[
		"const ",
		identifier,
		` = new ${TargetJS.internalObjectIdentifier}.Type("` + interfaceName + '"',
		", [",
		...propertiesWithTypes,
		"], [",
		...functionsWithTypes,
		"])",
	],
];
\end{lstlisting}

\subsection{Runtime Generation for Builtin Types}
Builtin runtime types are the used as parts of more complex constructs like interfaces. Comparing builtin runtime types at runtime happens by comparing their references, as they are uniquely defined at the start of the target language output in a global scope. They are implemented like the examples in  \ref{lst:implementation:builtinruntimetypes}. In addition to these types there are also builtin implementations for generic types. These include arrays and functions.

\begin{lstlisting}[language=Typescript,caption=Generic builtin types,label=lst:implementation:genericbuiltintypes]
const __type_Array = new KipperGenericType('Array', undefined, undefined, {T: __type_any});
const __type_Func = new KipperGenericType('Func', undefined, undefined, {T: [], R: __type_any});	
\end{lstlisting}

As can be seen in example \ref{lst:implementation:genericbuiltintypes}, they are implemented using a special KipperGenericType class. This class extends the KipperType and includes an additional field for generic arguments. Most importantly, it includes the method changeGenericTypeArguments, which allows for modifying a types generic arguments at runtime. It is used for example in lambdas and arrays, where the builtin generic runtime type is used and the modified to include the required types. When, for example an array is initialized, it first gets assigned the "\_\_type\_Array" runtime type, which is then modified by the changeGenericTypeArguments method. Arrays for example use the specified type for their elements, whilst functions require a return type as well as an array of arguments, which have types as well. The "\_\_type\_Func" type is used by lambdas, which are user defined functions without a name.

\begin{lstlisting}[language=Typescript,caption=Generic Kipper Type,label=lst:implementation:generickippertype]
class KipperGenericType extends KipperType {
	constructor(name, fields, methods, genericArgs, baseType = null) {
		super(name, fields, methods, baseType);
		this.genericArgs = genericArgs;
	}
	isCompatibleWith(obj) {
		return this.name === obj.name;
	}
	changeGenericTypeArguments(genericArgs) {
		return new KipperGenericType(
		this.name,
		this.fields,
		this.methods,
		genericArgs,
		this.baseType
		);
	}
}
\end{lstlisting}

Other builtin types are error type.They are used in the error handling system to represent errors. The base "KipperError" type has a name property and extends the target language's error type as can be seen in code snippet \ref{lst:implementation:kippererrortypes}. Additional error types inherit of this base type. The "KipperNotImplementedError" for example just changes the name of the error. As of now it is not possible for the user to create custom error types, due to inheritance not being implemented yet . The user will have to use the builtin error type and change it's name. 

\begin{lstlisting}[language=Typescript,caption=Kipper error types,label=lst:implementation:kippererrortypes]
class KipperError extends Error {
	constructor(msg) {
		super(msg);
		this.name = "KipError";
	}
}
class KipperNotImplementedError extends KipperError {
	constructor(msg) {
		super(msg);
		this.name = "KipNotImplementedError";
	}
}
\end{lstlisting}

\subsection{Matches operator}
\label{subsec:matches}

\subsection{Typeof operator}
\label{subsec:typeof}