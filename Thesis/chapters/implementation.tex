\section{Internal Compiler}
\setauthor{Luna Klatzer}

\section{Semantic Analysis}
\setauthor{Luna Klatzer}

\section{Type Analysis}
\setauthor{Luna Klatzer}

\section{Output Generation}
\setauthor{Lorenz Holzbauer}

\subsection{Introduction}

\subsection{Algorithms used for Output Generation}

\subsection{Types of Generated Statements}

\subsection{Differences between the Target Languages}

\subsection{Stylistic Choices}

\section{Type System}
\setauthor{Fabian Baitura}

\section{Integrated Runtime}
\setauthor{Lorenz Holzbauer}

\subsection{Runtime Type Concept}

The primary goal of the Kipper runtime type system is to allow untyped values to be compared with defined types, such as primitives, arrays, functions, classes, and interfaces, removing any ambiguities that could cause errors. During code generation, all user-defined interfaces are converted into runtime types that store the information needed to perform type checks. These are then utilised alongside the built-in runtime types, such as "num", "str" or "obj", to enable the compiler to add necessary checks and runtime references for any cast, match or typeof operation.

With the exception of interfaces, classes, and generics, types are primarily distinguished by their names. In these cases, type equality checks are performed using nominal comparisons, where the name acts as a unique identifier within the given scope e.g. type "num" is only assignable to "num". For more complex structures, additional information—such as members or generic parameters—is also considered.

In the case of interfaces, the names and types of fields and methods are used as discriminators. These fields and methods represent the minimum blueprint that an object must implement to be considered compatible with the interface and thus "assignable." In this regard, Kipper adopts the same duck-typing approach found in TypeScript.

For generics, which include "Array<T>" and "Func<T..., R>", the identifier is used alongside the provided generic parameters to determine assignability. This ensures that when one generic is assigned to another, all parameters must match. For instance, "Array<num>" cannot be assigned to "Array<str>" and vice versa, even if their overall structure is identical.

For user-defined classes, the compiler relies on the prototype to serve as the discriminator. In practice, this behaviour is similar to that of primitives, as different classes cannot be assigned to each other.

To ensure future compatibility with inheritance, Kipper also includes a "baseType" property, which allows types to be linked in an inheritance chain. However, this feature is currently unused.

\subsection{Runtime Type Implementations in other Languages}
\label{chap:runtime-other-languages}
Nominal type systems are used in most modern object-orientated programming languages like Java and C\#.  In these systems, types are compared by their name. Furthermore they are treated as equal, if one type is a subtype of the other one, as can bee seen in example \ref{lst:implementation:javanominaltyping}. Here a Programmer is an Employee, but not the other way around. This means, that Programmers have all the properties and methods an Employee has, but can additionally bring their own. The relationships are inherited, so a SeniorDeveloper is still an Employee, and a Programmer at the same time. Even though the Senior Developer adds no new functionality to the Programmer, it is not treated the same. Nominal typing improves code readability and maintainability, due to the explicit inheritance declaration. On the other hand, this increases code redundancy for similar, but not related structures.

\begin{lstlisting}[language=Java,caption=Example of nominal typing in java,label=lst:implementation:javanominaltyping]
class Employee {
	public float salary;
}

class Programmer extends Employee {
	public float bonus;
}

class SeniorDeveloper extends Programmer { }
\end{lstlisting}

Structural type systems compare types by their structure. This means, if two differently named types have the same properties and methods, then they are the same type. An example of this would be OCaml, with it's object subsystem being typed this way. Classes in OCaml only serve as functions for creating objects. In example \ref{lst:implementation:ocamlstructuraltyping} there is a function that required a function "speak" returning the type "string". Both the "dog" object as well as the "cat" object fulfill this condition, therefore both are treated equal. Most importantly, these compatibility checks happen at compile time, as OCaml is a static language. Structural typing allows for a lot of flexibility as it promotes code reuse. Furthermore it avoids explicit inheritance hierarchies.

\begin{lstlisting}[language=caml,caption=Example of structural typing in Ocaml,label=lst:implementation:ocamlstructuraltyping]
	let make_speak (obj : < speak : string >) =
	obj#speak
	
	let dog = object
	method speak = "Woof!"
	end
	
	let cat = object
	method speak = "Meow!"
	end
	
	let () =
	print_endline (make_speak dog);
	print_endline (make_speak cat);
\end{lstlisting}

Duck Typing is the usage of a structural type system in dynamic languages. It is the practical application of the Duck Test, therefore if it quacks like a duck, and walks like a duck, then it must be a duck. In programming languages this means that if an object has all methods and properties required by a type, then it is that type. The most prominent language utilizing Duck Typing is JavaScript. As can be seen in example \ref{lst:implementation:javascriptducktyping}, the duck and the person have the same methods and properties, henceforth they are of the same type. The dog object on the other hand does not implement the "quack" function, which equates to not  being a duck. Duck typing simplifies the code by removing type constraints, while still encouraging polymorphism without complex inheritance. Due to the type checking happening at runtime, errors only surface at this time, potentially causing failures. For developers, the lack of type information makes understanding the code harder and more tedious to maintain.

\begin{lstlisting}[language=Typescript,caption=Example of duck typing in JavaScript,label=lst:implementation:javascriptducktyping]
const duck = {
	quack: function () {
		console.log("Quack!");
	}
};

const person = {
	quack: function () {
		console.log("I'm a person but I can quack!");
	}
};

const dog = {
	bark: function () {
		console.log("Woof!");
	}
};
\end{lstlisting}

\subsection{Runtime Base Type}

In practice, all user-defined and built-in types inherit from a basic "KipperType" class in the runtime environment. A primitive version of such a class can be seen in listing ~\ref{lst:implementation:runtimetypestructure}.

\begin{lstlisting}[language=TypeScript,caption=The structure of a runtime type,label=lst:implementation:runtimetypestructure]
	class KipperType {
		constructor(name, fields, methods, baseType = undefined, customComparer = undefined) {
			this.name = name; 
			this.fields = fields;
			this.methods = methods;
			this.baseType = baseType;
			this.customComparer = customComparer;
		}
		
		accepts(obj) {
			if (this === obj) return true;
			return obj instanceof KipperType && this.customComparer ? this.customComparer(this, obj) : false;
		}
	}
\end{lstlisting}

As already mentioned types primarily rely on identifier checks to differentiate themselves from other types. Given though that there are slight differences in how types operate, they generally define themselves with what they are compatible using a comparator function. This comparator is already predefined for all built-ins in the runtime library and is also the same for all interfaces, as they all share the same equality behaviour.

Type "any" is an exception to the rule and accepts any value you provide. However, assigning "any" to anything other than "any" is forbidden and it is necessary to cast it to a different type in order to use the stored value. By design "any" is as useless as possible, in order to force the developer into typechecking it.

Furthermore, classes are also exempt from this comparator behaviour, as classes behave like a value during runtime and provide a prototype which can simply be used to check if an object is an instance of that class.

\begin{lstlisting}[language=TypeScript,caption=Examples for the builtin runtime types,label=lst:implementation:builtinruntimetypes]
	const __type_any = 
	new KipperType('any', undefined, undefined);
	
	const __type_undefined = 
	new KipperType('undefined', undefined, undefined, undefined, (a, b) => a.name === b.name);
	
	const __type_str = 
	new KipperType('str', undefined, undefined, undefined, (a, b) => a.name === b.name);
\end{lstlisting}

\subsection{Runtime Generation for Interfaces}

The generation of runtime interface types allows for dynamic type checking against interfaces in the target languages. This process is managed by the RuntimeTypesGenerator class, which is called by the code-generator and adds a JavaScript object to the compiled code that represents the structure of the interface. It therefore includes the interface's methods and properties with their respective types.

\begin{lstlisting}[language=Typescript,caption=Example interfaces in the Kipper language,label=lst:implementation:inputinterface]
interface Car {
	brand: str;
	honk(volume: num): void;
	year: num;
}

interface Person {
	name: str;
	age: num;
	car: Car;
}
\end{lstlisting}

 At compile time, the generator function iterates over the interface's members and differentiates between properties and methods. The function keeps separate lists of already generated runtime representations for properties and methods.
 
 If it detects a property, the type and semantic data of the given property is extracted. When the property's type is a built in type, the respective runtime type of the previous section is used. If not, we can assume the property's type is another interface, which has it's own runtime type already. This data is stored in "\_\_kipper.Property", which is finally added to the list of generated runtime type representation
 
 In case a method is detected, the generator function fetches the return type and the method's name. If the method has arguments, the name and type of each argument gets evaluated and stored in the same internal Kipper type as above, because the type representation of properties and arguments is equivalent. After that, it gets added to the list of type representations as well.

\begin{lstlisting}[language=Typescript,caption=The runtime representation of the previous interfaces,label=lst:implementation:runtimeinterface]
const __intf_Car = new __kipper.Type(
	"Car",
	[
		new __kipper.Property("brand", __kipper.builtIn.str),
		new __kipper.Property("year", __kipper.builtIn.num),
	],
	[
		new __kipper.Method("honk", __kipper.builtIn.void, 
			[
				new __kipper.Property("volume", __kipper.builtIn.num),
			]
		),
	]
);

const __intf_Person = new __kipper.Type(
	"Person",
	[
		new __kipper.Property("name", __kipper.builtIn.str),
		new __kipper.Property("age", __kipper.builtIn.num),
		new __kipper.Property("car", __intf_Car),
	],
	[]
);
\end{lstlisting}

The generated output code in the target language is a string array, which later gets concatenated into a single output string as can bee seen in \ref{lst:implementation:codegenerationstatement}. The properties and methods are wrapped into a Kipper type object that represents the final interface runtime type. It is saved into a constant with a \_\_intf\_ prefix. This runtime type-checking object code is then placed under the compiled interface's code. Notable usages for runtime typechecking include the "matches" operator \ref{subsec:matches} and the typeof operator \ref{subsec:typeof}.

\begin{lstlisting}[language=Typescript,caption=Code generation statement ,label=lst:implementation:codegenerationstatement]
return [
	[
		"const ",
		identifier,
		` = new ${TargetJS.internalObjectIdentifier}.Type("` + interfaceName + '"',
		", [",
		...propertiesWithTypes,
		"], [",
		...functionsWithTypes,
		"])",
	],
];
\end{lstlisting}

\subsection{Runtime Generation for Builtin Types}
Builtin runtime types are the used as parts of more complex constructs like interfaces. Comparing builtin runtime types at runtime happens by comparing their references, as they are uniquely defined at the start of the target language output in a global scope. They are implemented like the examples in  \ref{lst:implementation:builtinruntimetypes}. In addition to these types there are also builtin implementations for generic types. These include arrays and functions.

\begin{lstlisting}[language=Typescript,caption=Generic builtin types,label=lst:implementation:genericbuiltintypes]
const __type_Array = new KipperGenericType('Array', undefined, undefined, {T: __type_any});
const __type_Func = new KipperGenericType('Func', undefined, undefined, {T: [], R: __type_any});	
\end{lstlisting}

As can be seen in example \ref{lst:implementation:genericbuiltintypes}, they are implemented using a special KipperGenericType class. This class extends the KipperType and includes an additional field for generic arguments. Most importantly, it includes the method changeGenericTypeArguments, which allows for modifying a types generic arguments at runtime. It is used for example in lambdas and arrays, where the builtin generic runtime type is used and the modified to include the required types. When, for example an array is initialized, it first gets assigned the "\_\_type\_Array" runtime type, which is then modified by the changeGenericTypeArguments method. Arrays for example use the specified type for their elements, whilst functions require a return type as well as an array of arguments, which have types as well. The "\_\_type\_Func" type is used by lambdas, which are user defined functions without a name.

\begin{lstlisting}[language=Typescript,caption=Generic Kipper Type,label=lst:implementation:generickippertype]
class KipperGenericType extends KipperType {
	constructor(name, fields, methods, genericArgs, baseType = null) {
		super(name, fields, methods, baseType);
		this.genericArgs = genericArgs;
	}
	isCompatibleWith(obj) {
		return this.name === obj.name;
	}
	changeGenericTypeArguments(genericArgs) {
		return new KipperGenericType(
		this.name,
		this.fields,
		this.methods,
		genericArgs,
		this.baseType
		);
	}
}
\end{lstlisting}

Other builtin types are error type. They are used in the error handling system to represent errors. The base "KipperError" type has a name property and extends the target language's error type as can be seen in code snippet \ref{lst:implementation:kippererrortypes}. Additional error types inherit of this base type. The "KipperNotImplementedError" for example just changes the name of the error. As of now it is not possible for the user to create custom error types, due to inheritance not being implemented yet . The user will have to use the builtin error type and change it's name.

\begin{lstlisting}[language=Typescript,caption=Kipper error types,label=lst:implementation:kippererrortypes]
class KipperError extends Error {
	constructor(msg) {
		super(msg);
		this.name = "KipError";
	}
}
class KipperNotImplementedError extends KipperError {
	constructor(msg) {
		super(msg);
		this.name = "KipNotImplementedError";
	}
}
\end{lstlisting}

\subsection{Matches operator}
\label{subsec:matches}

The main feature of the Kipper programming language is it's runtime type comparison. There are multiple ways to compare objects at runtime. The instanceof operator compares by reference. This means, that an object is an instance of a class, when there is a reference to that class. This works by utilizing JavaScripts prototype system. Another way to compare objects would be comparison by structure. This aproach treats two objects as equal, when they share the same structure, as in the same properties and methods. Kipper allows for comparison with both options. Comparison by reference is implemented using the 'instanceof' operator and only utilized for comparing classes. Comparison by structure is what we call 'matching' and is used for primitives and interfaces. Matching array and function types is not yet supported in Kipper. The 'matches' operator in Kipper implements this type of comparison.

\begin{lstlisting}[language=Typescript,caption=The Kipper matches operator,label=lst:implementation:matchesoperator]
interface Y {
	v: bool;
	t(gr: str): num;
}

interface X {
	y: Y;
	z: num;
}

var x: X = {
	y: {
		v: true,
		t: (gr: str): num -> {
			return 0;
		}
	},
	z: 5
};

var res: bool = x matches X; // true
\end{lstlisting}

As can be seen in example \ref{lst:implementation:matchesoperator}, the matches operator can compare interfaces by properties and methods. It takes two arguments, an object and a type which it should match. Properties are compared recursivly and methods are compared by name, arguments and return type.

Comparison works by iterating over the methods and properties. When iterating over the properties, it checks for the property's name being in the type it should check against \ref{lst:implementation:matchesproperty}. The order of properties does not matter. When the name was found, it checks for type equality. This checking is done using the aforementioned runtime types and nominal type comparison. In case a non-primitive is detected as the properties type, the matches function will be recursively executed on non-primitive.

\begin{lstlisting}[language=Typescript,caption=Matches operator property comparison,label=lst:implementation:matchesproperty]
for (const field of pattern.fields) {
  const fieldName = field.name;
  const fieldType = field.type;

  if (!(fieldName in value)) {
    return false;
  }

  const fieldValue = value[fieldName];
  const isSameType = __kipper.typeOf(fieldValue) === field.type;

  if (primTypes.includes(field.type.name) && !isSameType) {
    return false;
  }

  if (!primTypes.includes(fieldType.name)) {
    if (!__kipper.matches(fieldValue, fieldType)) {
      return false;
    }
  }
}
\end{lstlisting}

After checking the properties, the matches expression iterates over the methods. It first searches for the method name in the target type. If found, it compares the return type. Then each argument is compared by name. As the methods signatures need to be exactly the same, the amount of parameters is compared as well. This ensures, that one method can not be a subset of the other one.

\begin{lstlisting}[language=Typescript,caption=Matches operator method comparison,label=lst:implementation:matchesmethod]
for (const field of pattern.methods) {
  const fieldName = field.name;
  const fieldReturnType = field.returnType;
  const parameters = field.parameters;

  if (!(fieldName in value)) {
    return false;
  }

  const fieldValue = value[fieldName];
  const isSameType = fieldReturnType === fieldValue.__kipType.genericArgs.R;

  if (!isSameType) {
    return false;
  }

  const methodParameters = fieldValue.__kipType.genericArgs.T;

  if (parameters.length !== methodParameters.length) {
    return false;
  }

  let count = 0;
  for (let param of parameters) {
    if (param.type.name !== methodParameters[count].name) {
      return false;
    }
    count++;
  }
}
\end{lstlisting}

When none of these condition is false, the input object matches the input type and they can be seen as the equal.

\subsection{Typeof operator}
\label{subsec:typeof}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../thesis"
%%% End:
