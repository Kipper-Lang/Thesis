\section{Internal Compiler}
\setauthor{Luna Klatzer}

\section{Semantic Analysis}
\setauthor{Luna Klatzer}

\section{Type Analysis}
\setauthor{Luna Klatzer}

\section{Output Generation}
\setauthor{Lorenz Holzbauer}

\subsection{Introduction}

\subsection{Algorithms used for Output Generation}

\subsection{Types of Generated Statements}

\subsection{Differences between the Target Languages}

\subsection{Stylistic Choices}

\section{Type System}
\setauthor{Fabian Baitura}

\subsection{Intended Purpose \& Concept}

\subsection{Existing Foundation \& Environment}

We have choosen to use JavaScript as our foundation for Kipper. What we have to work with will be described under

\subsubsection{Weak Dynamic Type System}

JavaScript is a dynamically typed language, meaning variables can hold values of different types during runtime. Unlike statically typed languages such as TypeScript or Java, JavaScript does not require explicit declaration of a variable's data type.

\begin{lstlisting}[caption=Holding Values of different Types during Runtime]
	let foo = 10; // foo is a number
	foo = "Hello"; // foo is now a string
	foo = [1, 2, 3, 4, 5]; // foo is now an array
\end{lstlisting}

In contrast, TypeScript enforces static typing, ensuring that a variable's type remains consistent throughout its lifecycle. This prevents unintentional type changes and improves code reliability.

\begin{lstlisting}[caption=Statically Typed Language TypeScript]
let foo: number = 1; // x is explicitly declared as a number
foo = "Hello"; // Error: Type 'string' is not assignable to type 'number'
\end{lstlisting}

JavaScript is also a weakly typed language, meaning that it allows operations between different data types without the need for explicit type conversion. This flexibility can sometimes lead to unexpected results, as JavaScript automatically coerces values to the appropriate type when performing operations.

\begin{lstlisting}[caption=Automatic type conversion in JavaScript]
	let quantity = 7; // quantity is an integer
	let value = "20"; // value is a string
	
	let total = quantity + value; // JavaScript automatically converts quantity to string
	console.log(total); // Output: "720"
\end{lstlisting}

In the example above, the number 7 is stored in the variable quantity, and the string "20" is stored in the variable value. Typically, when attempting to add a number and a string, one might expect an error due to the mismatch in data types. However, JavaScript performs implicit type coercion, automatically converting the number into a string before performing the operation.

In this case, JavaScript converts the number 7 to the string "7" and concatenates it with the string "20", resulting in the string "720". This type conversion occurs implicitly, without the need for explicit instructions to JavaScript.

However, implicit type coercion can sometimes lead to unintended results if not handled carefully. It is important to understand how JavaScript performs these conversions to prevent unexpected behavior in your code. Awareness of these implicit conversions helps ensure that operations between different data types do not produce erroneous or undesirable outcomes.



\subsubsection{Primitives \& Core Types}

In JavaScript, a primitive (or primitive value, primitive data type) is a data type that is not an object and does not have methods or properties. There are seven primitive data types:

\begin{itemize}
	\item string
	\item number
	\item bigint
	\item boolean
	\item undefined
	\item symbol
	\item null
	
\end{itemize}

Unique among the primitive types in JavaScript are undefined and null. 

In JavaScript, null is considered a primitive value due to its seemingly simple nature. However, when using the typeof operator, it unexpectedly returns "object". This is a known quirk in JavaScript and is considered a historical bug in the language that has been maintained for compatibility reasons.

\begin{lstlisting}[caption=typeof null return "object" in JavaScript ]
	console.log(typeof null); // "object"
\end{lstlisting}

undefined is a primitive value automatically assigned to variables that have been declared but not yet assigned a value, or to formal function parameters for which no actual arguments are provided.

\begin{lstlisting}[caption=typeof null return "object" in JavaScript ]
	let item; // declare a variable without assigning a value
	
	console.log(`The value of item is ${item}`); // logs "The value of item is undefined"
	
\end{lstlisting}

All primitives in JavaScript are immutable, meaning they cannot be altered directly. It is important to distinguish between a primitive value and a variable that holds a primitive value. While a variable can be reassigned to a new value, the primitive value itself cannot be modified in the same way that objects, arrays, and functions can be altered. JavaScript does not provide utilities to mutate primitive values.

Primitives, such as numbers and strings, do not inherently have methods. However, they appear to behave as though they do, due to JavaScript's automatic wrapping, or "auto-boxing," of primitive values into their corresponding wrapper objects. For example, when a method like toString() is called on a primitive number, JavaScript internally creates a temporary Number object. The method is then executed on this object, not directly on the primitive value.

Consider the primitive value value = 10;. When a method such as value.toString() is invoked, JavaScript automatically wraps the primitive 10 in a Number object and calls Number.prototype.toString() on it. This behavior occurs invisibly to the programmer and serves as a helpful mental model for understanding various behaviors in JavaScript. For example, when attempting to "mutate" a primitive, such as assigning a property to a string (str.foo = 1), the original string is not modified. Instead, the value is assigned to a temporary wrapper object.


\subsubsection{Custom Dynamic Structures}

\subsubsection{Prototype Inheritance System}

\subsection{Translating the foundation to Kipper}

\subsection{Drawing comparisons to TypeScript}

\subsection{Kipper Primitives}

\subsection{Kipper Generics}

\newpage

\subsection{Kipper Interfaces \& Duck-Typing}

\subsection{Kipper Classes \& Prototyping}

\section{Integrated Runtime}
\setauthor{Lorenz Holzbauer}

\subsection{Runtime Type Concept}

The primary goal of the Kipper runtime type system is to allow untyped values to be compared with defined types, such as primitives, arrays, functions, classes, and interfaces, removing any ambiguities that could cause errors. During code generation, all user-defined interfaces are converted into runtime types that store the information needed to perform type checks. These are then utilised alongside the built-in runtime types, such as "num", "str" or "obj", to enable the compiler to add necessary checks and runtime references for any cast, match or typeof operation.

With the exception of interfaces, classes, and generics, types are primarily distinguished by their names. In these cases, type equality checks are performed using nominal comparisons, where the name acts as a unique identifier within the given scope e.g. type "num" is only assignable to "num". For more complex structures, additional information—such as members or generic parameters—is also considered.

In the case of interfaces, the names and types of fields and methods are used as discriminators. These fields and methods represent the minimum blueprint that an object must implement to be considered compatible with the interface and thus "assignable." In this regard, Kipper adopts the same duck-typing approach found in TypeScript.

For generics, which include "Array<T>" and "Func<T..., R>", the identifier is used alongside the provided generic parameters to determine assignability. This ensures that when one generic is assigned to another, all parameters must match. For instance, "Array<num>" cannot be assigned to "Array<str>" and vice versa, even if their overall structure is identical.

For user-defined classes, the compiler relies on the prototype to serve as the discriminator. In practice, this behaviour is similar to that of primitives, as different classes cannot be assigned to each other.

To ensure future compatibility with inheritance, Kipper also includes a "baseType" property, which allows types to be linked in an inheritance chain. However, this feature is currently unused.

\subsection{Runtime Type Implementations in other Languages}
\label{chap:runtime-other-languages}

\subsubsection{Nominal Type Systems}

Nominal type systems are used in most modern object-orientated programming languages like Java and C\#. In these systems, types are identified by their unique names and can only be assigned to themselves. Additionally, two types are considered compatible, if one type is a subtype of the other one, as can bee seen in listing \ref{lst:implementation:javanominaltyping}. Here a "Programmer" is an "Employee", but not the other way around. This means that "Programmer" instances have all the properties and methods an "Employee" has while also having additional ones specific to "Programmer". The relationships are as such inherited, so a "SeniorDeveloper" is still an "Employee" and a "Programmer" at the same time. Even though the Senior Developer adds no new functionality to the "Programmer", it is not treated the same. Nominal typing improves code readability and maintainability, due to the explicit inheritance declaration. On the other hand, this increases code redundancy for similar or even identical but not related structures.

\begin{lstlisting}[language=Java,caption=Example of nominal typing in java,label=lst:implementation:javanominaltyping]
class Employee {
	public float salary;
}

class Programmer extends Employee {
	public float bonus;
}

class SeniorDeveloper extends Programmer { }
\end{lstlisting}

\subsubsection{Structural Type Systems}

Structural type systems compare types by their structure. This means, if two differently named types have the same properties and methods, then they are the same type. An example of this would be OCaml, with its object subsystem being typed this way. Classes in OCaml only serve as functions for creating objects. In example \ref{lst:implementation:ocamlstructuraltyping} there is a function that required a function "speak" returning the type "string". Both the "dog" object as well as the "cat" object fulfill this condition, therefore both are treated equal. Most importantly, these compatibility checks happen at compile time, as OCaml is a static language. Structural typing allows for a lot of flexibility as it promotes code reuse. Furthermore it avoids explicit inheritance hierarchies.

\begin{lstlisting}[language=caml,caption=Example of structural typing in Ocaml,label=lst:implementation:ocamlstructuraltyping]
	let make_speak (obj : < speak : string >) =
	obj#speak
	
	let dog = object
	method speak = "Woof!"
	end
	
	let cat = object
	method speak = "Meow!"
	end
	
	let () =
	print_endline (make_speak dog);
	print_endline (make_speak cat);
\end{lstlisting}

\subsubsection{Duck Typed Systems - Duck Typing}

Duck Typing is the usage of a structural type system in dynamic languages. It is the practical application of the "Duck Test", therefore if it quacks like a duck, and walks like a duck, then it must be a duck. In programming languages this means that if an object has all methods and properties required by a type, then it is of that type. The most prominent language utilizing Duck Typing is TypeScript. As can be seen in listing \ref{lst:implementation:javascriptducktyping}, the duck and the person have the same methods and properties, henceforth they are of the same type. The dog object on the other hand does not implement the "quack" function, which equates to not being a duck. Duck typing simplifies the code by removing type constraints, while still encouraging polymorphism without complex inheritance.

\begin{lstlisting}[language=Typescript,caption=Example of duck typing in TypeScript,label=lst:implementation:javascriptducktyping]
interface Duck {
	quack(): void;	
}

const duck: Duck = {
	quack: function () {
		console.log("Quack!");
	}
};

const person: Duck = {
	quack: function () {
		console.log("I'm a person but I can quack!");
	}
};

const dog: Duck = {
	bark: function () {
		console.log("Woof!");
	}
}; // <- causes an error in the static type checker
\end{lstlisting}

Given that duck typing allows dynamic data to be easily checked and assigned to any interface, Kipper adopts a similar system to that of TypeScript but introduces notable differences in how interfaces behave and how dynamic data is handled. For instance, casting an "any" object to an interface in Kipper will result in a runtime error if the object does not possess all the required members. In contrast, TypeScript permits such an operation without performing any type checks at runtime.

\subsection{Runtime Base Type}
\label{subsec:basetype}

In practice, all user-defined and built-in types inherit from a basic "KipperType" class in the runtime environment. This class is a simple blueprint of what a type could do and what forms a type may take on. A simple version of such a class can be seen in listing ~\ref{lst:implementation:runtimetypestructure}.

\begin{lstlisting}[language=TypeScript,caption=The structure of a runtime type,label=lst:implementation:runtimetypestructure]
	class KipperType {
		constructor(name, fields, methods, baseType = undefined, customComparer = undefined) {
			this.name = name; 
			this.fields = fields;
			this.methods = methods;
			this.baseType = baseType;
			this.customComparer = customComparer;
		}
		
		accepts(obj) {
			if (this === obj) return true;
			return obj instanceof KipperType && this.customComparer ? this.customComparer(this, obj) : false;
		}
	}
\end{lstlisting}

As already mentioned types primarily rely on identifier checks to differentiate themselves from other types. Given though that there are slight differences in how types operate, they generally define themselves with what they are compatible using a comparator function. This comparator is already predefined for all built-ins in the runtime library and any user structures build on top of the existing rules established in the library.

Type "any" is an exception and is the only type that accepts any value you provide. However, assigning "any" to anything other than "any" is forbidden and it is necessary to cast it to a different type in order to use the stored value. By design "any" is as useless as possible, in order to force the developer into typechecking it.

Furthermore, classes are also exempt from this comparator behaviour, as classes behave like a value during runtime and provide a prototype which can simply be used to check if an object is an instance of that class.

\subsection{Runtime Built-in Types}

Built-in runtime types serve as the foundation of the type system and make up the parts of more complex constructs like interfaces. Built-in runtime types are compared at runtime by comparing their references, as they are uniquely defined at the start of the output code and available in the global scope. The implementations of such structures can be seen in the listing~\ref{lst:implementation:builtinruntimetypes} down below.

\begin{lstlisting}[language=TypeScript,caption=Examples for the built-in runtime types,label=lst:implementation:builtinruntimetypes]
	const __type_any = 
	new KipperType('any', undefined, undefined);
	
	const __type_undefined = 
	new KipperType('undefined', undefined, undefined, undefined, (a, b) => a.name === b.name);
	
	const __type_str = 
	new KipperType('str', undefined, undefined, undefined, (a, b) => a.name === b.name);
\end{lstlisting}

In addition to the core primitive types—such as "bool", "str", "num", and others—there are built-in implementations for generic types, including "Array<T>" and "Func<T..., R>". These additionally define their generic parameters which generally default to a standard "any" type as can be seen in listing~\ref{lst:implementation:genericbuiltintypes}.

\begin{lstlisting}[language=Typescript,caption=Generic built-in types,label=lst:implementation:genericbuiltintypes]
const __type_Array = new KipperGenericType('Array', undefined, undefined, {T: __type_any});
const __type_Func = new KipperGenericType('Func', undefined, undefined, {T: [], R: __type_any});	
\end{lstlisting}

As can be seen in listing~\ref{lst:implementation:genericbuiltintypes}, generic types are implemented using a special "KipperGenericType" class. This class, shown in listing~\ref{lst:implementation:generickippertype}, extends the "KipperType" and includes an additional field for generic arguments. Most importantly, it includes the method "changeGenericTypeArguments", which allows for modifying a type's generic arguments at runtime. It is used in lambda and array definitions, where the built-in generic runtime type is used and then modified to represent the specified generic parameters. When for example an array is initialized, it first gets assigned the default "Array<any>" runtime type, which is then modified by the "changeGenericTypeArguments" method to create the required type, such as "Array<num>". Arrays for example use the specified type for their elements, whilst functions require a return type as well as an array of argument types. The "Func<T..., R>" type on the other hand is used by lambda definitions, which are user-defined functions with a specific return type and arguments without a name.

\begin{lstlisting}[language=Typescript,caption=Generic Kipper Type,label=lst:implementation:generickippertype]
class KipperGenericType extends KipperType {
	constructor(name, fields, methods, genericArgs, baseType = null) {
		super(name, fields, methods, baseType);
		this.genericArgs = genericArgs;
	}
	isCompatibleWith(obj) {
		return this.name === obj.name;
	}
	changeGenericTypeArguments(genericArgs) {
		return new KipperGenericType(
		this.name,
		this.fields,
		this.methods,
		genericArgs,
		this.baseType
		);
	}
}
\end{lstlisting}

\subsection{Runtime Errors}

Other built-ins include error classes, which are used in the error handling system to represent runtime errors caused by invalid user operations. The base "KipperError" type has a name property and extends the target language's error type as can be seen in listing~\ref{lst:implementation:kippererrortypes}. Additional error types inherit this base type and extend it with additional error information. For instance, the "KipperNotImplementedError" is used whenever a feature that is not yet implemented is used by the developer.

\begin{lstlisting}[language=Typescript,caption=Kipper error types,label=lst:implementation:kippererrortypes]
class KipperError extends Error {
	constructor(msg) {
		super(msg);
		this.name = "KipError";
	}
}
class KipperNotImplementedError extends KipperError {
	constructor(msg) {
		super(msg);
		this.name = "KipNotImplementedError";
	}
}
\end{lstlisting}

\subsection{Runtime Generation for Interfaces}

Unlike TypeScript, in Kipper all interfaces possess a runtime counterpart, which stores all the required information to verify type compatibility during runtime. This process is managed by the Kipper code generator, which adds custom type instances to the compiled code that represent the structures of the user-defined interfaces with all its methods and properties including their respective types.

Now take for example the given interfaces seen in listing~\ref{lst:implementation:inputinterface}.

\begin{lstlisting}[language=Typescript,caption=Example interfaces in the Kipper language,label=lst:implementation:inputinterface]
	interface Car {
		brand: str;
		honk(volume: num): void;
		year: num;
	}
	
	interface Person {
		name: str;
		age: num;
		car: Car;
	}
\end{lstlisting}

At compile time, the generator function iterates over the interface's members and differentiates between properties and methods. The function keeps separate lists of already generated runtime representations for properties and methods.

If it detects a property, the type and semantic data of the given property is extracted. When the property's type is a built-in type, the respective runtime type already provided by the Kipper runtime library is used. If not, we can assume the property's type is a reference to another type structure, which will be simply referenced in our new type structure. This data is stored in an instance of "\_\_kipper.Property", which is finally added to the list of properties in the interface.

In case a method is detected, the generator function fetches the return type and the method's name. If the method has any arguments, the name and type of each argument also gets evaluated and then included in the definition of the "\_\_kipper.Method". After that, it gets added to the interface as well and is stored in its own separate method list.

If we translate the interfaces shown above in listing~\ref{lst:implementation:inputinterface} it would look similar to that in listing~\ref{lst:implementation:runtimeinterface}.

\begin{lstlisting}[language=Typescript,caption=The runtime representation of the previous interfaces,label=lst:implementation:runtimeinterface]
	const __intf_Car = new __kipper.Type(
		"Car",
		[
			new __kipper.Property("brand", __kipper.builtIn.str),
			new __kipper.Property("year", __kipper.builtIn.num),
		],
		[
			new __kipper.Method("honk", __kipper.builtIn.void, 
				[
					new __kipper.Property("volume", __kipper.builtIn.num),
				]
			),
		]
	);
	
	const __intf_Person = new __kipper.Type(
		"Person",
		[
			new __kipper.Property("name", __kipper.builtIn.str),
			new __kipper.Property("age", __kipper.builtIn.num),
			new __kipper.Property("car", __intf_Car),
		],
		[]
	);
\end{lstlisting}

As shown in listing~\ref{lst:implementation:runtimeinterface}, the properties and methods of an interface are encapsulated within a "KipperType" instance, identified by the "\_\_intf\_" prefix. The code for this runtime interface is included directly in the output file, where it can be accessed by any functionality that requires it. To reference the generated interface, the compiler maintains a symbol table that tracks all defined interfaces. The code generator then inserts runtime references to these interfaces wherever necessary.

Notable usages for runtime typechecking include the "matches" operator \ref{subsec:matches} and the "typeof" operator \ref{subsec:typeof}.

\subsection{Matches operator for Interfaces}
\label{subsec:matches}

The primary feature of the Kipper programming language is its runtime type comparison. There are multiple approaches for comparing objects at runtime. One method is comparison by reference, which is implemented using the "instanceof" operator. This method determines that an object is an instance of a class if there is a reference to that class, leveraging JavaScript's prototype system.

Another approach is comparison by structure, where two objects are considered equal if they share the same structure, meaning they have the same properties and methods. Kipper supports both methods of comparison. Reference-based comparison is implemented via the "instanceof" operator and is exclusively used for class comparisons. Structural comparison, referred to as "matching," is applied to primitives and interfaces. Structural comparisons are implemented using the matches operator as can been seen in listing~\ref{lst:implementation:runtimeinterface}.

\begin{lstlisting}[language=Typescript,caption=The Kipper matches operator,label=lst:implementation:matchesoperator]
interface Y {
	v: bool;
	t(gr: str): num;
}

interface X {
	y: Y;
	z: num;
}

var x: X = {
	y: {
		v: true,
		t: (gr: str): num -> {
			return 0;
		}
	},
	z: 5
};

var res: bool = x matches X; // -> true
\end{lstlisting}

As can be seen in example \ref{lst:implementation:matchesoperator}, the matches operator can compare interfaces by properties and methods. It takes two arguments, an object and a type which it should match. Properties are compared recursively and methods are compared by name, arguments and return type.

Comparison works by iterating over the methods and properties. When iterating over the properties, it checks for the property's name being present in the type it should check against. The order of properties does not matter. When the name is found, it checks for type equality. This checking is done using the aforementioned runtime types and nominal type comparison. In case a non-primitive is detected as the properties type, the matches function will be recursively executed on non-primitives.

This property match algorithm is implemented as can seen in listing~\ref{lst:implementation:matchesproperty}.

\begin{lstlisting}[language=Typescript,caption=Matches operator property comparison,label=lst:implementation:matchesproperty]
for (const field of pattern.fields) {
  const fieldName = field.name;
  const fieldType = field.type;

  if (!(fieldName in value)) {
    return false;
  }

  const fieldValue = value[fieldName];
  const isSameType = __kipper.typeOf(fieldValue) === field.type;

  if (primTypes.includes(field.type.name) && !isSameType) {
    return false;
  }

  if (!primTypes.includes(fieldType.name)) {
    if (!__kipper.matches(fieldValue, fieldType)) {
      return false;
    }
  }
}
\end{lstlisting}

After checking the properties, the matches expression iterates over the methods. It first searches for the method name in the target type. If found, it compares the return type. Then each argument is compared by name. As the methods signatures need to be exactly the same, the amount of parameters is compared as well.

\begin{lstlisting}[language=Typescript,caption=Matches operator method comparison,label=lst:implementation:matchesmethod]
for (const field of pattern.methods) {
  const fieldName = field.name;
  const fieldReturnType = field.returnType;
  const parameters = field.parameters;

  if (!(fieldName in value)) {
    return false;
  }

  const fieldValue = value[fieldName];
  const isSameType = fieldReturnType === fieldValue.__kipType.genericArgs.R;

  if (!isSameType) {
    return false;
  }

  const methodParameters = fieldValue.__kipType.genericArgs.T;

  if (parameters.length !== methodParameters.length) {
    return false;
  }

  let count = 0;
  for (let param of parameters) {
    if (param.type.name !== methodParameters[count].name) {
      return false;
    }
    count++;
  }
}
\end{lstlisting}

When none of these condition is false, the input object matches the input type and they can be seen as compatible.

\subsection{Typeof operator}
\label{subsec:typeof}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../thesis"
%%% End:
